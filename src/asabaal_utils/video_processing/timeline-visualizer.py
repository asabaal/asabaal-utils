import matplotlib.pyplot as plt
import numpy as np
import json
import argparse
from typing import List, Dict, Any


def load_analysis_report(report_path: str) -> Dict:
    """Load the analysis report generated by the LyricVideoAnalyzer."""
    with open(report_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def visualize_timeline(report: Dict, output_file: str = None):
    """
    Create a visual representation of the timeline showing covered and missing lyrics.
    
    Args:
        report: Analysis report from LyricVideoAnalyzer
        output_file: Path to save the output image (if None, displays the plot)
    """
    # Extract data from the report
    missing_clips = report.get('missing_clips', [])
    summary = report.get('analysis_summary', {})
    covered_count = summary.get('covered_lyrics', 0)
    missing_count = summary.get('missing_lyrics', 0)
    total_count = summary.get('total_lyrics', 0)
    
    # Convert timestamp strings to seconds for plotting
    def timestamp_to_seconds(timestamp: str) -> float:
        parts = timestamp.split(':')
        if len(parts) == 3:
            hours, minutes, seconds = parts
            return float(hours) * 3600 + float(minutes) * 60 + float(seconds)
        return 0
    
    # Prepare data for timeline
    missing_starts = [timestamp_to_seconds(clip['start_time']) for clip in missing_clips]
    missing_durations = [clip['duration'] for clip in missing_clips]
    missing_labels = [f"{clip['index']}: {clip['text'][:20]}..." if len(clip['text']) > 20 else clip['text'] 
                     for clip in missing_clips]
    
    # Create the figure
    plt.figure(figsize=(14, 8))
    
    # Plot the timeline
    y_pos = np.arange(len(missing_starts))
    
    # Plot bars for missing clips
    plt.barh(y_pos, missing_durations, left=missing_starts, height=0.5, 
             color='red', alpha=0.6, label='Missing Clips')
    
    # Add text labels
    for i, (start, duration, label) in enumerate(zip(missing_starts, missing_durations, missing_labels)):
        plt.text(start + duration/2, i, label, 
                 ha='center', va='center', color='black', fontsize=8)
    
    # Set labels and title
    plt.yticks(y_pos, [f"Lyric {i+1}" for i in range(len(missing_starts))])
    plt.xlabel('Time (seconds)')
    plt.title(f'Lyric Timeline Analysis - {missing_count}/{total_count} missing clips')
    
    # Add a legend and grid
    plt.legend()
    plt.grid(axis='x', alpha=0.3)
    
    # Add coverage summary
    coverage_text = (f"Timeline Coverage: {summary.get('coverage_percentage', 0)}%\n"
                     f"Covered Lyrics: {covered_count}/{total_count}\n"
                     f"Missing Lyrics: {missing_count}/{total_count}")
    plt.figtext(0.02, 0.02, coverage_text, fontsize=10, 
                bbox=dict(facecolor='white', alpha=0.8))
    
    # Adjust layout
    plt.tight_layout()
    
    # Save or display the plot
    if output_file:
        plt.savefig(output_file, dpi=300)
        print(f"Timeline visualization saved to {output_file}")
    else:
        plt.show()


def main():
    parser = argparse.ArgumentParser(description='Visualize CapCut timeline analysis')
    parser.add_argument('--report', required=True, help='Path to analysis report JSON file')
    parser.add_argument('--output', help='Output image file path (PNG/JPG/PDF)')
    
    args = parser.parse_args()
    
    try:
        report = load_analysis_report(args.report)
        visualize_timeline(report, args.output)
    except Exception as e:
        print(f"Error: {str(e)}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
