#!/usr/bin/env python3
"""
Video Sample Creator Tool

Creates short sample videos from longer videos for faster iteration and testing.
Supports custom duration, start time, and various output options.
"""

# description: Create sample videos from longer videos for faster iteration and testing
# version: 1.0.0
# category: media

import argparse
import subprocess
import sys
from pathlib import Path
from typing import Optional


def check_dependencies():
    """Check if FFmpeg is installed."""
    try:
        result = subprocess.run(['ffmpeg', '-version'], 
                              capture_output=True, check=True, text=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def get_video_duration(video_path: str) -> float:
    """Get video duration in seconds using ffprobe."""
    try:
        cmd = [
            'ffprobe', '-v', 'quiet', '-print_format', 'csv=p=0',
            '-select_streams', 'v:0', '-show_entries', 'format=duration',
            video_path
        ]
        result = subprocess.run(cmd, capture_output=True, check=True, text=True)
        return float(result.stdout.strip())
    except (subprocess.CalledProcessError, ValueError):
        return 0.0


def create_sample_video(
    input_video: str,
    output_video: Optional[str] = None,
    duration: int = 30,
    start_time: int = 0,
    quality: str = "copy",
    show_info: bool = False
) -> bool:
    """
    Create a sample video using ffmpeg.
    
    Args:
        input_video: Path to input video
        output_video: Path to output video (optional)
        duration: Duration in seconds (default: 30)
        start_time: Start time in seconds (default: 0)
        quality: Quality mode - "copy" (fast) or "high" (re-encode)
        show_info: Show video information before processing
        
    Returns:
        True if successful, False otherwise
    """
    input_path = Path(input_video)
    
    if not input_path.exists():
        print(f"❌ Error: Input video {input_video} not found!")
        return False
    
    # Get video info if requested
    if show_info:
        video_duration = get_video_duration(str(input_path))
        print(f"📹 Video Information:")
        print(f"   File: {input_path.name}")
        print(f"   Duration: {video_duration:.1f} seconds ({video_duration/60:.1f} minutes)")
        print(f"   Size: {input_path.stat().st_size / (1024*1024):.1f} MB")
        print()
    
    # Generate output filename if not provided
    if output_video is None:
        suffix = f"_sample_{duration}s"
        if start_time > 0:
            suffix += f"_from_{start_time}s"
        output_video = input_path.parent / f"{input_path.stem}{suffix}{input_path.suffix}"
    
    output_path = Path(output_video)
    
    print(f"🎬 Creating {duration}-second sample...")
    print(f"   Input: {input_path.name}")
    print(f"   Output: {output_path.name}")
    print(f"   Start time: {start_time}s")
    print(f"   Quality mode: {quality}")
    
    # Build ffmpeg command based on quality mode
    if quality == "copy":
        # Fast mode - copy streams without re-encoding
        cmd = [
            'ffmpeg',
            '-i', str(input_path),
            '-ss', str(start_time),        # Start time
            '-t', str(duration),           # Duration
            '-c', 'copy',                  # Copy streams
            '-avoid_negative_ts', 'make_zero',  # Handle timestamp issues
            '-y',                          # Overwrite output file
            str(output_path)
        ]
    else:
        # High quality mode - re-encode
        cmd = [
            'ffmpeg',
            '-i', str(input_path),
            '-ss', str(start_time),
            '-t', str(duration),
            '-c:v', 'libx264',            # Re-encode video
            '-c:a', 'aac',                # Re-encode audio
            '-crf', '23',                 # Good quality
            '-preset', 'fast',            # Fast encoding
            '-y',
            str(output_path)
        ]
    
    try:
        # Run ffmpeg with minimal output
        result = subprocess.run(
            cmd, 
            capture_output=True, 
            text=True, 
            check=True
        )
        
        # Check output file
        if output_path.exists():
            file_size_mb = output_path.stat().st_size / (1024*1024)
            print(f"✅ Sample created successfully!")
            print(f"   Output: {output_path}")
            print(f"   Size: {file_size_mb:.1f} MB")
            return True
        else:
            print(f"❌ Output file was not created")
            return False
            
    except subprocess.CalledProcessError as e:
        print(f"❌ FFmpeg error (return code: {e.returncode})")
        
        # Show error details for debugging
        if e.stderr:
            print(f"Error details: {e.stderr}")
        
        # Try fallback if copy mode failed
        if quality == "copy":
            print("\n🔄 Copy mode failed, trying with re-encoding...")
            return create_sample_video(
                input_video, str(output_path), duration, start_time, 
                quality="high", show_info=False
            )
        
        return False
    
    except FileNotFoundError:
        print("❌ Error: ffmpeg not found. Please install ffmpeg first.")
        print("Install from: https://ffmpeg.org/download.html")
        return False


def main():
    parser = argparse.ArgumentParser(
        description="Create sample videos for faster iteration",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  video-sample movie.mp4
  video-sample movie.mp4 -d 60 -s 120
  video-sample movie.mp4 -o sample.mp4 --quality high
  video-sample movie.mp4 --info -d 15
  video-sample *.mp4 --batch -d 30

Quality modes:
  copy  - Fast, copy streams without re-encoding (default)
  high  - Slower, re-encode with high quality settings
        """
    )
    
    parser.add_argument('input', nargs='+', 
                       help='Input video file(s) or pattern')
    parser.add_argument('-o', '--output', 
                       help='Output video file path (auto-generated if not provided)')
    parser.add_argument('-d', '--duration', type=int, default=30,
                       help='Sample duration in seconds (default: 30)')
    parser.add_argument('-s', '--start', type=int, default=0,
                       help='Start time in seconds (default: 0)')
    parser.add_argument('-q', '--quality', choices=['copy', 'high'], default='copy',
                       help='Quality mode: copy (fast) or high (re-encode, default: copy)')
    parser.add_argument('--info', action='store_true',
                       help='Show video information before processing')
    parser.add_argument('--batch', action='store_true',
                       help='Process multiple files (use with wildcards)')
    
    args = parser.parse_args()
    
    # Check dependencies
    if not check_dependencies():
        print("❌ Error: FFmpeg is required but not installed.")
        print("Install from: https://ffmpeg.org/download.html")
        sys.exit(1)
    
    # Handle batch mode
    input_files = []
    if args.batch:
        import glob
        for pattern in args.input:
            expanded = glob.glob(pattern)
            if expanded:
                input_files.extend(expanded)
            else:
                print(f"⚠️  Warning: No files match pattern: {pattern}")
    else:
        input_files = args.input
    
    if not input_files:
        print("❌ No input files specified or found.")
        sys.exit(1)
    
    # Validate output argument for multiple files
    if len(input_files) > 1 and args.output:
        print("❌ Error: Cannot specify custom output filename for multiple input files.")
        print("Use --batch mode and let filenames be auto-generated.")
        sys.exit(1)
    
    # Process files
    successful = 0
    failed = 0
    
    for input_file in input_files:
        if len(input_files) > 1:
            print(f"\n🎬 Processing: {input_file}")
        
        success = create_sample_video(
            input_file,
            args.output,
            args.duration,
            args.start,
            args.quality,
            args.info
        )
        
        if success:
            successful += 1
        else:
            failed += 1
    
    # Summary for batch operations
    total = successful + failed
    if total > 1:
        print(f"\n📊 Summary: {successful}/{total} files processed successfully")
        if failed > 0:
            print(f"   ❌ {failed} files failed")
    
    sys.exit(0 if failed == 0 else 1)


if __name__ == '__main__':
    main()