#!/usr/bin/env python3
"""
Video to Audio Converter Tool

Extracts audio tracks from video files and converts them to various audio formats.
Supports batch processing, quality control, and multiple output formats.
"""

# description: Extract and convert audio from video files with support for multiple formats and quality settings
# version: 1.0.0
# category: media

import argparse
import sys
import os
import subprocess
from pathlib import Path
from typing import Optional, List, Dict, Union
import json

def check_dependencies():
    """Check if FFmpeg is installed."""
    try:
        result = subprocess.run(['ffmpeg', '-version'], 
                              capture_output=True, check=True, text=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def get_video_info(video_path: str) -> Dict:
    """Get video information using ffprobe."""
    try:
        cmd = [
            'ffprobe', '-v', 'quiet', '-print_format', 'json',
            '-show_format', '-show_streams', video_path
        ]
        result = subprocess.run(cmd, capture_output=True, check=True, text=True)
        return json.loads(result.stdout)
    except (subprocess.CalledProcessError, json.JSONDecodeError):
        return {}

def extract_audio(
    input_file: str,
    output_file: str,
    format: str = "mp3",
    quality: str = "192k",
    channels: Optional[int] = None,
    sample_rate: Optional[int] = None,
    start_time: Optional[str] = None,
    duration: Optional[str] = None,
    normalize: bool = False
) -> bool:
    """
    Extract audio from video file using FFmpeg.
    
    Args:
        input_file: Path to input video file
        output_file: Path to output audio file
        format: Output audio format (mp3, wav, flac, aac, ogg)
        quality: Audio quality/bitrate (e.g., "192k", "320k")
        channels: Number of audio channels (1=mono, 2=stereo)
        sample_rate: Sample rate in Hz (e.g., 44100, 48000)
        start_time: Start time for extraction (e.g., "00:01:30")
        duration: Duration to extract (e.g., "00:05:00")
        normalize: Apply audio normalization
    
    Returns:
        True if successful, False otherwise
    """
    cmd = ['ffmpeg', '-i', input_file]
    
    # Time range options
    if start_time:
        cmd.extend(['-ss', start_time])
    if duration:
        cmd.extend(['-t', duration])
    
    # Audio codec and quality based on format
    codec_map = {
        'mp3': 'libmp3lame',
        'wav': 'pcm_s16le',
        'flac': 'flac',
        'aac': 'aac',
        'ogg': 'libvorbis',
        'm4a': 'aac'
    }
    
    if format in codec_map:
        cmd.extend(['-c:a', codec_map[format]])
        
        # Quality settings
        if format in ['mp3', 'aac', 'ogg', 'm4a']:
            cmd.extend(['-b:a', quality])
        elif format == 'flac':
            # FLAC uses compression level instead of bitrate
            cmd.extend(['-compression_level', '8'])
    
    # Channel configuration
    if channels:
        cmd.extend(['-ac', str(channels)])
    
    # Sample rate
    if sample_rate:
        cmd.extend(['-ar', str(sample_rate)])
    
    # Audio normalization
    if normalize:
        cmd.extend(['-af', 'loudnorm'])
    
    # Output options
    cmd.extend(['-vn'])  # No video
    cmd.extend(['-y'])   # Overwrite output file
    cmd.append(output_file)
    
    try:
        print(f"Extracting audio: {Path(input_file).name} -> {Path(output_file).name}")
        if start_time or duration:
            print(f"Time range: {start_time or '00:00:00'} to {duration or 'end'}")
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print("âœ“ Audio extraction completed successfully")
            return True
        else:
            print(f"âœ— FFmpeg error: {result.stderr}")
            return False
            
    except Exception as e:
        print(f"âœ— Extraction failed: {e}")
        return False

def process_file(
    input_path: str,
    output_dir: str,
    format: str = "mp3",
    quality: str = "192k",
    channels: Optional[int] = None,
    sample_rate: Optional[int] = None,
    start_time: Optional[str] = None,
    duration: Optional[str] = None,
    normalize: bool = False,
    show_info: bool = False
) -> bool:
    """Process a single video file."""
    input_file = Path(input_path)
    if not input_file.exists():
        print(f"âœ— Input file not found: {input_path}")
        return False
    
    # Show video information if requested
    if show_info:
        info = get_video_info(str(input_file))
        if info:
            print(f"\nðŸ“¹ Video Information for {input_file.name}:")
            print("-" * 50)
            
            format_info = info.get('format', {})
            print(f"Duration: {format_info.get('duration', 'Unknown')} seconds")
            print(f"Bitrate: {format_info.get('bit_rate', 'Unknown')} bps")
            
            # Audio stream info
            audio_streams = [s for s in info.get('streams', []) if s.get('codec_type') == 'audio']
            if audio_streams:
                stream = audio_streams[0]
                print(f"Audio Codec: {stream.get('codec_name', 'Unknown')}")
                print(f"Sample Rate: {stream.get('sample_rate', 'Unknown')} Hz")
                print(f"Channels: {stream.get('channels', 'Unknown')}")
                print(f"Audio Bitrate: {stream.get('bit_rate', 'Unknown')} bps")
            print()
    
    # Create output directory
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Generate output filename
    base_name = input_file.stem
    output_file = output_path / f"{base_name}.{format}"
    
    return extract_audio(
        str(input_file), str(output_file), format, quality,
        channels, sample_rate, start_time, duration, normalize
    )

def main():
    parser = argparse.ArgumentParser(
        description="Extract audio from video files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  video-to-audio video.mp4
  video-to-audio video.mp4 -f wav -q 320k -o audio/
  video-to-audio video.mp4 -f mp3 --normalize --channels 2
  video-to-audio video.mp4 -s 00:01:30 -d 00:03:00
  video-to-audio *.mp4 -f aac --batch
  video-to-audio video.mp4 --info

Supported formats: mp3, wav, flac, aac, ogg, m4a
Quality examples: 128k, 192k, 256k, 320k (for compressed formats)
        """
    )
    
    parser.add_argument('input', nargs='+', help='Input video file(s) or pattern')
    parser.add_argument('-o', '--output', default='./audio',
                       help='Output directory (default: ./audio)')
    parser.add_argument('-f', '--format', default='mp3',
                       choices=['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'],
                       help='Output audio format (default: mp3)')
    parser.add_argument('-q', '--quality', default='192k',
                       help='Audio quality/bitrate (default: 192k)')
    parser.add_argument('-c', '--channels', type=int,
                       help='Number of audio channels (1=mono, 2=stereo)')
    parser.add_argument('-r', '--sample-rate', type=int,
                       help='Sample rate in Hz (e.g., 44100, 48000)')
    parser.add_argument('-s', '--start-time',
                       help='Start time for extraction (e.g., 00:01:30)')
    parser.add_argument('-d', '--duration',
                       help='Duration to extract (e.g., 00:05:00)')
    parser.add_argument('-n', '--normalize', action='store_true',
                       help='Apply audio normalization')
    parser.add_argument('--info', action='store_true',
                       help='Show video information before extraction')
    parser.add_argument('--batch', action='store_true',
                       help='Process multiple files (use with wildcards)')
    
    args = parser.parse_args()
    
    # Check dependencies
    if not check_dependencies():
        print("Error: FFmpeg is required but not installed.")
        print("Install it from: https://ffmpeg.org/download.html")
        sys.exit(1)
    
    # Expand file patterns if batch mode
    input_files = []
    if args.batch:
        import glob
        for pattern in args.input:
            expanded = glob.glob(pattern)
            if expanded:
                input_files.extend(expanded)
            else:
                print(f"Warning: No files match pattern: {pattern}")
    else:
        input_files = args.input
    
    if not input_files:
        print("No input files specified or found.")
        sys.exit(1)
    
    # Process files
    successful = 0
    failed = 0
    
    for input_file in input_files:
        print(f"\nðŸŽ¬ Processing: {input_file}")
        
        success = process_file(
            input_file, args.output, args.format, args.quality,
            args.channels, args.sample_rate, args.start_time,
            args.duration, args.normalize, args.info
        )
        
        if success:
            successful += 1
        else:
            failed += 1
    
    # Summary
    total = successful + failed
    if total > 1:
        print(f"\nðŸ“Š Summary: {successful}/{total} files processed successfully")
        if failed > 0:
            print(f"   {failed} files failed")
    
    sys.exit(0 if failed == 0 else 1)

if __name__ == '__main__':
    main()